length(my_vector)
dim(my_vector) <- c(4,5)
dim(my_vector)
attributes(my_vector)
my_vector
class(my_vector)
my_matrix <- my_vector
?matrix
my_matrix2 <- matrix(my_matrix)
my_matrix2 <- matrix(1:20, nrow=4, ncol = 5)
identical(my_matrix, my_matrix2)
patients <-c("Bill","Gina","Kelly")
patients <-c("Bill","Gina","Kelly","Sean")
cbind(patients,my_matrix)
my_data <- data.frame(patients,_my_matrix)
my_data <- data.frame(patients,my_matrix)
my_data
class(my_data)
cnames <- c("patient","age","weight","bp","rating","test")
colnames(my_data)
colnames(my_data) <- cnames
my_data
swirl()
swirl()
library(swirl)
swirl()
TRUE==TRUE
(FALSE == TRUE) == FALSE
6==7
6<7
10<=10
5!=7
NOT(5!-7)
NOT(5!=7)
NOT(5==7)
?NOT
5!=7
!(5==7)
FALSE&FALSE
TRUE & c(TRUE,FALSE,FALSE)
TRUE && (TRUE,FALSE,FALSE)
TRUE && C(TRUE,FALSE,FALSE)
TRUE && c(TRUE, FALSE, FALSE)
TRUE | c(TRUE, FALSE, FALSE)
TRUE || c(TRUE, FALSE, FALSE)
5 > 8 ||
| 6 != 8 && 4 > 3.9
5>8||6!=8&&4>3.9
isTRUE(6>4)
identical("twins","twins")
xor(5==6, !FALSE)
ints <- sample(10)
ints
ints>5
which(ints>7)
any(ints<0)
all(ints>0)
Sys.Date()
bye()
exit
x<-1:4
lapply(x,runif,min=0,max=10)
library(swirl)
swirl()
mean(c(2,4,5))
submit()
boring_function('My first function!')
boring_function
submit()
submit()
my_mean(c(4,5,10))
submit()
remainder(5)
remainder(11,5)
remainder(divisor = 11, num = 5)
remainder(4, div = 2)
args(remainder)
submit()
evaluate(c(1.4, 3.6, 7.9, 8.8))
evaluate(std,c(1.4, 3.6, 7.9, 8.8))
evaluate(sd,c(1.4, 3.6, 7.9, 8.8))
evaluate(function(x){x+1}, 6)
evaluate(function(x){x[1]}, c(8,4,0))
evaluate(function(x){x[length(x)]}, c(8,4,0))
?paste
paste("Programming", "is", "fun!")
submit()
submit()
submit()
submit()
submit()
submit()
telegram("What the f is going on?")
submit()
submit()
mad_libs(place="Ohio", adjective = "kiss", noun = "go on")
mad_libs(place="Ohio", adjective = "kiss", noun = "go on")
submit()
"I" %p% "love" %p% "R!"
library(swirl)
swirl()
head)flags
head(flags)
dim(flags)
class(flags)?
?
###
#
class(flags)
class(flags)
cls_list <- lapply(flags, class)
cls_list
class(cls_list)
as.character(cls_list)
cls_vect <- sapply(flags,class)
class(cls_vector)
class(cls_vect)
sum(flag$orange)
sum(flags$orange)
flag_colors <- flags[,11:17]
head(flag_colors)
lapply(flag_colors,sum)
sapply(flag_colors,sum)
sapply(flag_colors,mean)
flag_shapes <- flags[,19:23]
lapply(flag_shapes,range)
shape_mat <- sapply(flag_shapes,range)
shape_mat
class(shape_mat)
unique(c(3,4,5,5,5,6,6))
unique_vals <- lapply(flags,unique)
unique_vals
length(unique_vals)
sapply(unique_vals,length)
sapply(flags,unique)
lapply(unique_vals, function(elem) elem[2])
library(datasets)
data(iris)
?iris
Sepal.Length(iris)
iris(Sepal.Length)
iris[Sepal.Length=="virginica"]
head(iris)
x<-subset(iris,Species=="virginica")
x
sapply(x,mean)
apply(iris[, 1:4], 2, mean)
library(datasets)
data(mtcars)
?mtcars
y<-apply(mtcars, 2, mean)
y
z<-split(mtcars, mtcars$cyl)
z
w<-with(mtcars, tapply(mpg, cyl, mean))
w
q<-tapply(mtcars$cyl, mtcars$mpg, mean)
q
debug(ls)
ls(1,10)
exit
quit
quit()
head(mtcars)
x<-subset(mtcars,cyl=6)
x<-subset(mtcars,cyl=4)
y<-subset(mtcars,cyl=8)
dif<-sapply(y,mean)-sapply(x,mean)
dif
xm<-mean(x["hp"])
xm<-mean(x$hp)
xm<-mean(y$hp)
ym<-mean(y$hp)
xm<-mean(x$hp)
x
y
library(datasets)
data(mtcars)
x<-subset(mtcars,cyl=4)
x
x<-subset(mtcars,cyl="4")
x
mtcars
x<-subset(mtcars,mtcars$cyl="4")
x<-subset(mtcars,mtcars$cyl=4)
x<-subset(mtcars,mtcars$cyl==4)
x
y<-subset(mtcars,mtcars$cyl==8)
dif<-mean(y["hp"])-mean(x["hp"])
dif<-mean(y$hp)-mean(x$hp)
dif
set.seed(1)
rpois(5, 2)
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
library(swirl)
swirl()
sapply(flags,unique)
vapply(flags,unique,numeric(1))
ok()
sapply(flags,class)
vapply(flags,class,character(1))
?tapply
table(flags$landmass)
table(flags$animate)
tapply(flags$animate,flags$landmass,mean)
tapply(flags$population, flags$red, summary)
summary(population)
summary("population")
tapply(flags$population,flags$landmass,summary)
ls()
class(plants)
dim(plants)
nrow(plants)
ncol(plants)
object.size(plants)
names(plants)
head(plants)
head9plants,10
head(plants,10)
tail(plants,15)
summary(plants)
table(plants$Active_Growth_Period)
str(plants)
library(genalg)
library(ggplot2)
package?
()
install.packages("genalg")
install.packages("ggplot2")
library(genalg)
library(ggplot2)
dataset <- data.frame(item = c("pocketknife", "beans", "potatoes", "unions",
"sleeping bag", "rope", "compass"), survivalpoints = c(10, 20, 15, 2, 30,
10, 30), weight = c(1, 5, 10, 1, 7, 5, 1))
weightlimit <- 20
dataset
evalFunc <- function(x) {
current_solution_survivalpoints <- x %*% dataset$survivalpoints
current_solution_weight <- x %*% dataset$weight
if (current_solution_weight > weightlimit)
return(0) else return(-current_solution_survivalpoints)
}
iter = 100
GAmodel <- rbga.bin(size = 7, popSize = 200, iters = iter, mutationChance = 0.01,
elitism = T, evalFunc = evalFunc)
cat(summary.rbga(GAmodel))
x<-{1 2 3 4 5 6 7 8 9 10}
y<-numeric(15)
y<-numeric(1:15)
y[1]<-1
y[2]<2
y[2]<-2
for(i in 1:length(y)){y[i]<-i}
makeVektor(y)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
makeVektor(y)
makeVector(y)
makeVector$get
makeVector$get()
get
get()
get(x)
get(y)
x={1 2,3 5}
B = matrix(
+   c(2, 4, 3, 1, 5, 7),
+   nrow=3,
+   ncol=2)
B = matrix(c(2, 4, 3, 1, 5, 7),  nrow=3,  ncol=2)
B
B<-b(1:2,1:2)
B<-b(1:2,1:2)
B<-B(1:2,1:2)
B = matrix(c(2, 4, 3, 1),  nrow=2,  ncol=2)
solve(B)
B*solve(B)
solve(B)*B
setwd("Rprog")
getwd()
setwd("ProgrammingAssigment2")
setwd("ProgrammingAssignment2")
dir
dir()
source("cachematrix.R")
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
inv <- cacheSolve(x)
inv
inv <- cacheSolve(x)
inv
m <- matrix(c(-1, -2, 1, 1), 2,2)
##The functions below create an invertible matrix that is cached in the parent environment
##and allows the inverse to be computed and cached in the parent environment as well.
##After the inverse is initially calclulated, subsequent calls are retrieved from the
##parent environment instead of being re-calculated
##Function to cache an invertible matrix and its inverse
##x is the invertible matrix
makeCacheMatrix <- function(x = matrix()) {
##initiate the matrix's inverse, m
m <- NULL
##set the values of the invertible matrix in the parent environment;
##reset the matrix's inverse in the parent environment
set <- function(y) {
x <<- y
m <<- NULL
}
##call the matrix's values
get <- function() x
##compute the matrix's inverse and cache it in the parent environment
setinverse <- function(inverse) m <<- inverse
##retrieve the matrix's inverse
getinverse <- function() m
##create and return a list that contains the functions above
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
##Function to calculate the inverse of a matrix created with the 'makeCacheMatrix" function and
##store it in the parent environment
# x is the invertible matrix
# m is the inverse of the matrix
cacheSolve <- function(x, ...) {
#retrieve the matrix's inverse
m <- x$getinverse()
#if the inverse is already calculated and stored in the parent environment, return the inverse and exit
if(!is.null(m)) {
message("getting cached data")
return(m)
}
#if the inverse is not calculated, perform the calculation and return the inverse
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
x <- makeCacheMatrix(m)
x$get()
inv <- cacheSolve(x)
inv
inv <- cacheSolve(x)
inv
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
##
## makeCacheMatrix creates a matrix object that can cache its inverse
## function will do the following operations:
##    * set a matrix object
##    * get a matrix object
##    * set the inverse of the matrix given
##    * get the inverse of the matrix given
##      (if the matrix is the same, then gets it from cache)
makeCacheMatrix <- function(x = matrix()) {
## instantiate a inverse matrix holder
im <- NULL
## method to set the value of the matrix
set <- function(matrix) {
## instantiates the matrix for function use
x <<- matrix
## sets the inverse holder to null
im <<- NULL
}
## method to get the value of the matrix
get <- function() {
## returns the matrix
x
}
## method to set the inverse of the matrix
setInverse <- function(inverse) {
## sets the inverse holder to the inverse of the matrix
im <<- inverse
}
## method to get the inverse of the matrix
getInverse <- function() {
## returns the inverse matrix
im
}
## list the methods of the function
list(set = set, get = get,
setInverse = setInverse, getInverse = getInverse)
}
## Write a short comment describing this function
##
## cacheSolve computes the inverse of a matrix returned by makeCacheMatrix
## if the inverse has already been calculated (and there is no change to the matrix),
## then the function retrieves the inverse from cache rather than re-calculating.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
## get the inverse matrix if not already set
im <- x$getInverse()
## if the holder is not null, then get the cached data
if(!is.null(im)) {
message("getting cached data...")
return(im)
}
## get the matrix provided by the main makeCachematrix function
data <- x$get()
## calculate the inverse of the provided matrix and assign it to the holder
im <- solve(data, ...)
## set the inverse to the inverse holder object
x$setInverse(im)
## returns the inverse matrix
im
}
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
inv <- cacheSolve(x)
inv
inv <- cacheSolve(x)
inv
## These functions cache the inverse of a matrix. Matrix inversion is a costly
## computation, so it might be beneficial to cache the result for faster computation.
# This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## This function computes the inverse of the special "matrix"
## returned by makeCacheMatrix above. If the inverse has already
## been calculated (and the matrix has not changed),
## then the cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data)
x$setinverse(m)
m
}
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
inv <- cacheSolve(x)
inv
inv <- cacheSolve(x)
inv
## The function myCacheMatrix creates a special "matrix" object that can cache its inverse
## Here is how it works:
## myCacheMatrix takes as input a matrix x
## myCacheMatrix returns a list of functions in a separate environment "set, get, setinverse, getinverse"
## myCacheMatrix duplicates the input matrix x in the same environment as the functions in the list "set"
## myCacheMatrix creates an object m for temporary storage of the inverse "set"
## The function setinverse computes the inverse of x
## The function getinverse houses the matrix m which will be called in the next function as the location of the inverse of x
makeCacheMatrix<-function(x=matrix()){
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function()x
setinverse<-function(solve)x<<-solve
getinverse<-function()m
list(set=set,get=get,setinverse=setinverse,getinverse=getinverse)
}
## The function cacheSolve computes the inverse of the special "matrix"
## Here is how it works:
## cacheMatrix takes as input the function myCacheMatrix applied to matrix x
## If the inverse has already been calculated (and the matrix has not changed), then the cacheSolve should retrieve the inverse from the cache.
## cacheMatrix assigns the inverse of the matrix to the object m and returns m "m <- x$getinverse()"
cacheSolve <- function(x,...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x$get()
inv <- cacheSolve(x)
inv
inv <- cacheSolve(x)
